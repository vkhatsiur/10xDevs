# API Endpoint Implementation Plan: POST /api/flashcards

## 1. Endpoint Overview

The `POST /api/flashcards` endpoint is used to create one or more flashcards. It enables saving flashcards that are either manually created or generated by AI, while ensuring strict validation of input data and proper association with generation records (if applicable).

**Key Characteristics**:
- Accepts an **array** of flashcards (batch operation)
- Validates each flashcard in the array
- Supports both manual and AI-generated flashcards
- Returns all created flashcards with generated IDs

---

## 2. Request Details

### HTTP Method
`POST`

### URL Structure
`/api/flashcards`

### Request Body

```json
{
  "flashcards": [
    {
      "front": "What is TypeScript?",
      "back": "A typed superset of JavaScript",
      "source": "manual",
      "generation_id": null
    },
    {
      "front": "What is Astro?",
      "back": "A modern web framework",
      "source": "ai-full",
      "generation_id": 123
    }
  ]
}
```

### Required Parameters

#### `flashcards` (array)
Array of flashcard objects. Each object must contain:

##### `front` (string)
- **Required**: Yes
- **Type**: string
- **Max length**: 200 characters
- **Description**: Question or front side of flashcard

##### `back` (string)
- **Required**: Yes
- **Type**: string
- **Max length**: 500 characters
- **Description**: Answer or back side of flashcard

##### `source` (string)
- **Required**: Yes
- **Type**: enum
- **Allowed values**: `"ai-full"`, `"ai-edited"`, `"manual"`
- **Description**: Origin of the flashcard
  - `"ai-full"`: Generated by AI, not edited by user
  - `"ai-edited"`: Generated by AI, then edited by user
  - `"manual"`: Created manually by user

##### `generation_id` (number | null)
- **Required**: Depends on source
- **Type**: number or null
- **Rules**:
  - **Required** (not null) for `source: "ai-full"` or `source: "ai-edited"`
  - **Must be null** for `source: "manual"`
- **Description**: Reference to the generation that created this flashcard

### Optional Parameters
None

---

## 3. Used Types

```typescript
// Request types
interface FlashcardCreateDto {
  front: string;
  back: string;
  source: 'ai-full' | 'ai-edited' | 'manual';
  generation_id: number | null;
}

interface FlashcardsCreateRequest {
  flashcards: FlashcardCreateDto[];
}

// Response types
interface FlashcardDto {
  id: number;
  front: string;
  back: string;
  source: string;
  generation_id: number | null;
  user_id: string;
  created_at: string;
  updated_at: string;
}

interface FlashcardsCreateResponse {
  flashcards: FlashcardDto[];
}
```

---

## 4. Response Details

### Success Response

**Status Code**: `201 Created`

**Response Body**:
```json
{
  "flashcards": [
    {
      "id": 1,
      "front": "What is TypeScript?",
      "back": "A typed superset of JavaScript",
      "source": "manual",
      "generation_id": null,
      "user_id": "00000000-0000-0000-0000-000000000001",
      "created_at": "2025-11-17T10:00:00Z",
      "updated_at": "2025-11-17T10:00:00Z"
    },
    {
      "id": 2,
      "front": "What is Astro?",
      "back": "A modern web framework",
      "source": "ai-full",
      "generation_id": 123,
      "user_id": "00000000-0000-0000-0000-000000000001",
      "created_at": "2025-11-17T10:00:00Z",
      "updated_at": "2025-11-17T10:00:00Z"
    }
  ]
}
```

### Error Responses

#### 400 Bad Request
**Cause**: Validation errors

**Examples**:
```json
{
  "error": "Validation failed",
  "details": {
    "flashcards[0].front": "Front text exceeds maximum length of 200 characters"
  }
}
```

```json
{
  "error": "Validation failed",
  "details": {
    "flashcards[1].generation_id": "generation_id is required for ai-full source"
  }
}
```

```json
{
  "error": "Validation failed",
  "details": {
    "flashcards[0].source": "Invalid source value. Must be one of: ai-full, ai-edited, manual"
  }
}
```

#### 401 Unauthorized
**Cause**: Missing or invalid authentication token

```json
{
  "error": "Unauthorized",
  "message": "Authentication required"
}
```

#### 404 Not Found
**Cause**: Referenced generation_id doesn't exist

```json
{
  "error": "Generation not found",
  "details": {
    "generation_id": 123
  }
}
```

#### 500 Internal Server Error
**Cause**: Server error or database issues

```json
{
  "error": "Internal server error",
  "message": "Failed to create flashcards"
}
```

---

## 5. Data Flow

```
1. Client sends POST request with flashcards array
   ↓
2. API endpoint receives request (src/pages/api/flashcards/index.ts)
   ↓
3. Verify user authentication (get user_id)
   ↓
4. Validate request body structure (array exists, not empty)
   ↓
5. Validate each flashcard in array:
   - front: required, max 200 chars
   - back: required, max 500 chars
   - source: required, valid enum value
   - generation_id: null for manual, required for AI sources
   ↓
6. For AI sources, verify generation_id exists and belongs to user
   ↓
7. Call FlashcardService.createFlashcards()
   ↓
8. Service adds user_id to each flashcard
   ↓
9. Batch insert all flashcards (single database query)
   ↓
10. Return created flashcards with generated IDs
```

---

## 6. Security Considerations

### Authentication
- **Requirement**: User must be authenticated
- **Implementation**: Verify Supabase Auth token (Module 3)
- **MVP**: Use hardcoded test user ID

### Authorization
- **Requirement**: User can only create flashcards for themselves
- **Implementation**: Always set `user_id` from authenticated session
- **Verification**: For AI sources, verify generation belongs to user

### Input Validation
- **Sanitization**: Validate and sanitize all input fields
- **SQL Injection**: Use parameterized queries (Supabase handles this)
- **XSS Protection**: Sanitize text fields before storage (Module 3)
- **Length Limits**: Enforce maximum lengths at API layer AND database layer

### Data Integrity
- **Foreign Key Checks**: Verify generation_id exists before insertion
- **Atomic Operations**: Use transactions for batch inserts
- **Rollback**: If any flashcard fails validation, roll back entire operation

---

## 7. Error Handling

### Validation Errors (400)
```typescript
// Validation error structure
{
  error: "Validation failed",
  details: {
    "flashcards[index].field": "Error message"
  }
}
```

**Validation Rules**:
- Empty flashcards array → `"At least one flashcard is required"`
- Missing front → `"Front text is required"`
- Front too long → `"Front text exceeds maximum length of 200 characters"`
- Missing back → `"Back text is required"`
- Back too long → `"Back text exceeds maximum length of 500 characters"`
- Invalid source → `"Invalid source value. Must be one of: ai-full, ai-edited, manual"`
- AI source with null generation_id → `"generation_id is required for ai-full/ai-edited source"`
- Manual source with generation_id → `"generation_id must be null for manual source"`

### Authentication Errors (401)
- Missing token → `"Authentication required"`
- Invalid token → `"Invalid authentication token"`
- Expired token → `"Authentication token expired"`

### Not Found Errors (404)
- Generation doesn't exist → `"Generation not found"`
- Generation belongs to different user → `"Generation not found"` (don't reveal it exists)

### Database Errors (500)
- Connection failed → `"Internal server error"`
- Insert failed → `"Failed to create flashcards"`
- Log detailed errors server-side
- Return generic message to client

### Error Logging
```typescript
// Log structure
{
  timestamp: "2025-11-17T10:00:00Z",
  level: "error",
  user_id: "...",
  endpoint: "POST /api/flashcards",
  error: {
    message: "...",
    stack: "...",
    details: { ... }
  }
}
```

---

## 8. Performance Considerations

### Batch Processing
- **Strategy**: Single INSERT for all flashcards
- **Benefit**: Reduces database round trips
- **Implementation**: Use Supabase batch insert

```typescript
// Efficient batch insert
const { data, error } = await supabase
  .from('flashcards')
  .insert(flashcardsArray)
  .select();
```

### Validation Optimization
- Validate all flashcards before database operations
- Fail fast: Return error on first validation failure
- Avoid partial inserts (use transactions)

### Database Optimization
- Use prepared statements (Supabase default)
- Leverage database indexes on user_id, generation_id
- Use connection pooling (Supabase handles this)

### Limits
- **Recommended max**: 50 flashcards per request
- **Reason**: Balance between batch efficiency and request size
- **Future**: Implement pagination for very large batches

---

## 9. Implementation Steps

### Step 1: Create Validation Schema
**File**: `src/lib/validators/flashcard.validator.ts`

```typescript
import { z } from 'zod';

const flashcardSchema = z.object({
  front: z.string().min(1).max(200),
  back: z.string().min(1).max(500),
  source: z.enum(['ai-full', 'ai-edited', 'manual']),
  generation_id: z.number().nullable()
}).refine(
  (data) => {
    // For AI sources, generation_id must be present
    if ((data.source === 'ai-full' || data.source === 'ai-edited') && data.generation_id === null) {
      return false;
    }
    // For manual source, generation_id must be null
    if (data.source === 'manual' && data.generation_id !== null) {
      return false;
    }
    return true;
  },
  {
    message: "generation_id rules violated"
  }
);

export const flashcardsCreateSchema = z.object({
  flashcards: z.array(flashcardSchema).min(1).max(50)
});
```

### Step 2: Create Flashcard Service
**File**: `src/lib/services/flashcard.service.ts`

```typescript
import { getServiceSupabase } from '../supabase';
import type { TablesInsert } from '../../db/types';

export class FlashcardService {
  private supabase = getServiceSupabase();

  async createFlashcards(
    flashcards: Array<Omit<TablesInsert<'flashcards'>, 'user_id'>>,
    userId: string
  ) {
    // Add user_id to each flashcard
    const flashcardsWithUser = flashcards.map(fc => ({
      ...fc,
      user_id: userId
    }));

    // Batch insert
    const { data, error } = await this.supabase
      .from('flashcards')
      .insert(flashcardsWithUser)
      .select();

    if (error) {
      throw new Error(`Failed to create flashcards: ${error.message}`);
    }

    return data;
  }

  async verifyGenerationOwnership(
    generationId: number,
    userId: string
  ): Promise<boolean> {
    const { data, error } = await this.supabase
      .from('generations')
      .select('id')
      .eq('id', generationId)
      .eq('user_id', userId)
      .single();

    return !error && data !== null;
  }
}
```

### Step 3: Create API Endpoint
**File**: `src/pages/api/flashcards/index.ts`

```typescript
import type { APIRoute } from 'astro';
import { flashcardsCreateSchema } from '../../../lib/validators/flashcard.validator';
import { FlashcardService } from '../../../lib/services/flashcard.service';

export const POST: APIRoute = async ({ request }) => {
  try {
    // Parse request body
    const body = await request.json();

    // Validate request
    const validation = flashcardsCreateSchema.safeParse(body);
    if (!validation.success) {
      return new Response(
        JSON.stringify({
          error: 'Validation failed',
          details: validation.error.flatten().fieldErrors
        }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Get user ID (MVP: hardcoded, Module 3: from auth)
    const userId = '00000000-0000-0000-0000-000000000001';

    // Verify generation ownership for AI sources
    const flashcardService = new FlashcardService();
    for (const flashcard of validation.data.flashcards) {
      if (flashcard.generation_id !== null) {
        const isOwner = await flashcardService.verifyGenerationOwnership(
          flashcard.generation_id,
          userId
        );
        if (!isOwner) {
          return new Response(
            JSON.stringify({ error: 'Generation not found' }),
            { status: 404, headers: { 'Content-Type': 'application/json' } }
          );
        }
      }
    }

    // Create flashcards
    const createdFlashcards = await flashcardService.createFlashcards(
      validation.data.flashcards,
      userId
    );

    return new Response(
      JSON.stringify({ flashcards: createdFlashcards }),
      { status: 201, headers: { 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('Error creating flashcards:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
};
```

### Step 4: Add Error Logging
- Log all errors to console
- Include user_id, endpoint, request details
- Module 3: Add structured logging service

### Step 5: Testing
1. **Unit tests**: Test validation schema
2. **Integration tests**: Test service methods
3. **Manual tests**: Use curl/Postman
4. **Database verification**: Check records in Supabase Studio

---

## 10. Testing Examples

### Test Case 1: Create Manual Flashcard
```bash
curl -X POST http://localhost:4321/api/flashcards \
  -H "Content-Type: application/json" \
  -d '{
    "flashcards": [
      {
        "front": "What is Astro?",
        "back": "A modern web framework",
        "source": "manual",
        "generation_id": null
      }
    ]
  }'
```

### Test Case 2: Create AI Flashcards
```bash
curl -X POST http://localhost:4321/api/flashcards \
  -H "Content-Type: application/json" \
  -d '{
    "flashcards": [
      {
        "front": "Question 1",
        "back": "Answer 1",
        "source": "ai-full",
        "generation_id": 1
      },
      {
        "front": "Question 2",
        "back": "Answer 2",
        "source": "ai-full",
        "generation_id": 1
      }
    ]
  }'
```

### Test Case 3: Validation Error
```bash
# Front text too long (> 200 chars)
curl -X POST http://localhost:4321/api/flashcards \
  -H "Content-Type: application/json" \
  -d '{
    "flashcards": [
      {
        "front": "..."  // 201 characters
        "back": "Answer",
        "source": "manual",
        "generation_id": null
      }
    ]
  }'
```

---

## 11. Future Enhancements (Module 3+)

### Authentication
- Replace hardcoded user_id with authenticated session
- Add JWT token verification
- Implement proper authorization

### Rate Limiting
- Limit flashcard creation to prevent abuse
- Example: 100 flashcards per hour per user

### Bulk Operations
- Support very large batches (> 50 flashcards)
- Implement background job processing
- Add progress tracking

### Advanced Validation
- Duplicate detection (same front/back within user's flashcards)
- Content moderation (filter inappropriate content)
- Language detection and validation

### Analytics
- Track flashcard creation patterns
- Monitor AI vs manual ratio
- Identify popular topics

---

**Document Version**: 1.0
**Last Updated**: 2025-11-17
**Status**: Ready for Implementation
**Dependencies**: Database schema, Supabase client, TypeScript types
**Next Steps**: Implement validation, service, and endpoint
